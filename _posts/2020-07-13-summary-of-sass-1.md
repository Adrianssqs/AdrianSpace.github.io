---
layout: article
title: Sass总结与归纳（上）
tags: sass
key: article-sass-1
---

> 简介：Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。

<!--more-->

> 本篇是对Sass的归纳总结，通过使用Sass也可以像写js一样调用变量，编写函数以及判断、循环，甚至只用样式就写出轮播图的逻辑，而不用像以前那样，不只写样式，还要单独写js才能实现。通过阅读Sass的文档，发现css这块还是有很大提升空间的。

语法格式 (Syntax)
----------------

- 以 <b style="color:red;">.scss</b> 作为拓展名。在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。此外，SCSS 也支持大多数 CSS hacks 写法以及浏览器前缀写法 (vendor-specific syntax)，以及早期的 IE 滤镜写法。

- 以 <b style="color:red;">.sass</b> 作为拓展名。这种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 "Sass"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。

- 任何一种格式可以直接 导入 (@import) 到另一种格式中使用，或者通过 <b style="color:#ccc">sass-convert</b> 命令行工具转换成另一种格式：

  ```
    # Convert Sass to SCSS
    $ sass-convert style.sass style.scss

    # Convert SCSS to Sass
    $ sass-convert style.scss style.sass
  ```

### 1. 使用 Sass (Using Sass)

  先安装 Sass gem （Windows 系统需要先安装 Ruby）：

  ```
  gem install sass
  ```

  常用命令：

  ```
  // 监视单个 Sass 文件，每次修改并保存时自动编译：
  sass --watch input.scss:output.css

  // 监视整个文件夹：
  sass --watch app/sass:public/stylesheets
  ```

   缓存 (Caching)

   单独使用 Sass，缓存内容保存在 .sass-cache 文件夹中。在 Rails 和 Merb 项目中缓存文件保存在 tmp/sass-cache 文件夹中（可通过 :cache_location 修改路径）。禁用缓存可将 :cache 设为 false。

### 2. CSS 功能拓展 (CSS Extensions)

  - 2.1. 嵌套规则 (Nested Rules)

    Sass 允许将一套 CSS 样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如：

    ```scss
      #main p {
        color: #00ff00;
        width: 97%;

        .redbox {
          background-color: #ff0000;
          color: #000000;
        }
      }
    ```

  - 2.2. 父选择器 & (Referencing Parent Selectors: &)

    在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 & 代表嵌套规则外层的父选择器。

    ```scss
      a {
        font-weight: bold;
        text-decoration: none;

        &:hover { text-decoration: underline; }
        body.firefox & { font-weight: normal; }
      }
    ```

    编译为

    ```css
      a {
        font-weight: bold;
        text-decoration: none; }
        a:hover {
          text-decoration: underline; }
        body.firefox a {
          font-weight: normal; }

    ```

    & 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器，例如:

    ```scss
      #main {
        color: black;
        &-sidebar { border: 1px solid; }
      }
    ```

    编译为

    ```css
      #main {
        color: black; }
        #main-sidebar {
          border: 1px solid; }
    ```

    当父选择器含有不合适的后缀时，Sass 将会报错。

  - 2.3. 属性嵌套 (Nested Properties)

    ```scss
      .funky {
        font: {
          family: fantasy;
          size: 30em;
          weight: bold;
        }
      }
    ```

    编译为

    ```css
      .funky {
        font-family: fantasy;
        font-size: 30em;
        font-weight: bold; }
    ```

    命名空间也可以包含自己的属性值，例如：

    ```scss
      .funky {
        font: 20px/24px {
          family: fantasy;
          weight: bold;
        }
      }
    ```

### 3. 注释 /* */ 与  //

  > Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会。

  > 将 ! 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。

  插值语句 (interpolation) 也可写进多行注释中输出变量值：

  ```scss
    $version: "1.2.3";
    /* This CSS is generated by My Snazzy Framework version #{$version}. */
  ```

  编译为

  ```css
    /* This CSS is generated by My Snazzy Framework version 1.2.3. */
  ```

### 4. SassScript

  > 在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。

  - 4.1. **变量 $ (Variables: $)**

    SassScript 最普遍的用法就是变量，变量以美元符号开头，赋值方法与 CSS 属性的写法一样

    变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明:

    ```scss
      #main {
        $width: 5em !global;
        width: $width;
      }

      #sidebar {
        width: $width;
      }
    ```

    编译为

    ```css
      #main {
        width: 5em;
      }

      #sidebar {
        width: 5em;
      }
    ```

  - 4.2. **数据类型 (Data Types)**

    SassScript 支持 6 种主要的数据类型：

    - 数字，1, 2, 13, 10px
    - 字符串，有引号字符串与无引号字符串，"foo", 'bar', baz
    - 颜色，blue, #04a3f9, rgba(255,0,0,0.5)
    - 布尔型，true, false
    - 空值，null
    - 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
    - maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)

    SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。

    - **4.2.1 字符串 (Strings)**

      SassScript 支持 CSS 的两种字符串类型：有引号字符串 (quoted strings)，如 "Lucida Grande" 'SassScript'；与无引号字符串 (unquoted strings)，如 sans-serif bold，在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#{ }` 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名：

      ```scss
        @mixin firefox-message($selector) {
          body.firefox #{$selector}:before {
            content: "Hi, Firefox users!";
          }
        }
        @include firefox-message(".header");
      ```

      编译为

      ```css
        body.firefox .header:before {
          content: "Hi, Firefox users!"; }
      ```

    - **4.2.2 数组 (Lists)**

      数组 (lists) 指 Sass 如何处理 CSS 中 `margin: 10px 15px 0 0` 或者 `font-face: Helvetica, Arial, sans-serif` 这样通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。

      数组中可以包含子数组，比如 `1px 2px, 5px 6px` 是包含 `1px 2px` 与 `5px 6px` 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 `(1px 2px) (5px 6px)`。

      `(1px 2px) (5px 6px)` 与 `1px 2px, 5px 6px` 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。

  - 4.3. **运算 (Operations)**

    所有数据类型均支持相等运算 <b style="color:red;">==</b> 或 <b style="color:red;">!=</b>，此外，每种数据类型也有其各自支持的运算方式。

    - **4.3.1 数字运算 (Number Operations)**

      SassScript 支持数字的加减乘除、取整等运算 `(+, -, *, /, %)`，如果必要会在不同单位间转换值。

      关系运算 `<, >, <=, >=` 也可用于数字运算，相等运算 <b style="color:red;">==</b>, <b style="color:red;">!=</b> 可用于所有数据类型。

      - 4.3.1.1  除法运算 / (Division and /)

        以下三种情况 / 将被视为除法运算符号：

          - 如果值，或值的一部分，是变量或者函数的返回值
          - 如果值被圆括号包裹
          - 如果值是算数表达式的一部分

        ```scss
          p {
            font: 10px/8px;             // Plain CSS, no division
            $width: 1000px;
            width: $width/2;            // Uses a variable, does division
            width: round(1.5)/2;        // Uses a function, does division
            height: (500px/2);          // Uses parentheses, does division
            margin-left: 5px + 8px/2px; // Uses +, does division
          }
        ```

        编译为

        ```css
          p {
            font: 10px/8px;
            width: 500px;
            height: 250px;
            margin-left: 9px; }
        ```

        如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 `#{}` 插值语句将变量包裹。

        ```scss
          p {
            $font-size: 12px;
            $line-height: 30px;
            font: #{$font-size}/#{$line-height};
          }
        ```

        编译为

        ```css
          p {
            font: 12px/30px; }
        ```

    - **4.3.2 颜色值运算 (Color Operations)**

      颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值。

      需要注意的是，如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。

      ```scss
        p {
          color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
        }
      ```

      编译为

      ```css
        p {
          color: rgba(255, 255, 0, 0.75); }
      ```

      颜色值的 alpha channel 可以通过 `opacify` 或 `transparentize` 两个函数进行调整。

      ```scss
        $translucent-red: rgba(255, 0, 0, 0.5);
        p {
          color: opacify($translucent-red, 0.3);
          background-color: transparentize($translucent-red, 0.25);
        }
      ```

      编译为

      ```css
        p {
          color: rgba(255, 0, 0, 0.8);
          background-color: rgba(255, 0, 0, 0.25); }
      ```

      IE 滤镜要求所有的颜色值包含 alpha 层，而且格式必须固定 `#AABBCCDD`，使用 `ie_hex_str` 函数可以很容易地将颜色转化为 IE 滤镜要求的格式。

      ```scss
        $translucent-red: rgba(255, 0, 0, 0.5);
        $green: #00ff00;
        div {
          filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#{ie-hex-str($green)}', endColorstr='#{ie-hex-str($translucent-red)}');
        }
      ```

      编译为

      ```css
        div {
          filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);
        }
      ```

    - **4.3.3 字符串运算 (String Operations)**

      `+` 可用于连接字符串

      注意，如果有引号字符串（位于 `+` 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 `+` 左侧）连接有引号字符串，运算结果则没有引号。

      ```scss
        p:before {
          content: "Foo " + Bar;
          font-family: sans- + "serif";
        }
      ```

      编译为

      ```css
        p:before {
          content: "Foo Bar";
          font-family: sans-serif; }
      ```

      运算表达式与其他值连用时，用空格做连接符：

      ```scss
        p {
          margin: 3px + 4px auto;
        }
      ```

      编译为

      ```css
        p {
          margin: 7px auto; }
      ```

      在有引号的文本字符串中使用 `#{}` 插值语句可以添加动态的值：

      ```scss
        p:before {
          content: "I ate #{5 + 10} pies!";
        }
      ```

      编译为

      ```css
        p:before {
          content: "I ate 15 pies!"; }
      ```

      空的值被视作插入了空字符串.

    - **4.3.4 布尔运算 (Boolean Operations)**

      SassScript 支持布尔型 `and` `or` 以及 `not` 运算。

    - **4.3.5 数组运算 (List Operations)**

      数组不支持任何运算方式，只能使用 **list functions** 控制。

  - 4.4. **圆括号 (Parentheses)**

    圆括号可以用来影响运算的顺序：

    ```scss
      p {
        width: 1em + (2em * 3);
      }
    ```

  - 4.5. **函数 (Functions)**

    SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用。

    通过 [Sass::Script::Functions](http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html "Sass Built-In Modules"){:target="_blank"} 查看完整的 Sass 函数列表，参数名，以及如何自定义函数。

  - 4.6. **插值语句 `#{}` (Interpolation: `#{}`)**

    通过 `#{}` 插值语句可以在选择器或属性名中使用变量：

    ```scss
      $name: foo;
      $attr: border;
      p.#{$name} {
        #{$attr}-color: blue;
      }
    ```

    编译为

    ```css
      p.foo {
        border-color: blue; }
    ```

    `#{}` 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。

  - 4.7. **& in SassScript**

    可以在mixin中使用 `&` 来检测父选择器是否存在：

    ```scss
      @mixin does-parent-exist {
        @if & {
          &:hover {
            color: red;
          }
        } @else {
          a {
            color: red;
          }
        }
      }
    ```

  - 4.8. **变量定义 `!default` (Variable Defaults: `!default`)**

    可以在变量的结尾添加 `!default` 给一个未通过 `!default` 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。

    ```scss
      $content: "First content";
      $content: "Second content?" !default;
      $new_content: "First time reference" !default;

      #main {
        content: $content;
        new-content: $new_content;
      }
    ```

    编译为

    ```css
      #main {
        content: "First content";
        new-content: "First time reference"; }
    ```

    变量是 **null** 空值时将视为未被 `!default` 赋值。

### 5. @-Rules 与指令 (@-Rules and Directives)

  - **5.1. @import**

    Sass 拓展了 `@import` 的功能，允许其导入 SCSS 或 Sass 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。

    通常，`@import` 寻找 Sass 文件并将其导入，但在以下情况下，`@import` 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。

      - 文件扩展名是 `.css`;
      - 文件名以 `http://`开头;
      - 文件名是 `URL()`;
      - `@import` 包含media queries

    Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：

    ```scss
      @import "rounded-corners", "text-shadow";
    ```

    导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式：

    ```scss
      $family: unquote("Droid+Sans");
      @import url("http://fonts.googleapis.com/css?family=\#{$family}");
    ```

    编译为

    ```css
      @import url("http://fonts.googleapis.com/css?family=Droid+Sans");
    ```

    - **5.1.1  分音 (Partials)**

      如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线。

      例如，将文件命名为 `_colors.scss`，便不会编译 `_colours.css` 文件。

      ```scss
        @import "colors";
      ```

      上面的例子，导入的其实是 `_colors.scss` 文件

      > 注意，不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。

    - **5.1.2 嵌套 @import**

      可以将 @import 嵌套进 CSS 样式或者 @media 中，与平时的用法效果相同，只是这样导入的样式只能出现在嵌套的层中。

      ```scss
        #main {
          @import "example";
        }
      ```
      > 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 `@import`。

  - **5.2. @media**

    Sass 中 `@media` 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 `@media` 嵌套在 CSS 规则内，编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 `@media` 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。

    ```scss
      .sidebar {
        width: 300px;
        @media screen and (orientation: landscape) {
          width: 500px;
        }
      }
    ```

    编译为

    ```css
      .sidebar {
        width: 300px; }
        @media screen and (orientation: landscape) {
          .sidebar {
            width: 500px; } }
    ```

    `@media` 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 `and`

    ```scss
      @media screen {
        .sidebar {
          @media (orientation: landscape) {
            width: 500px;
          }
        }
      }
    ```

    编译为

    ```css
      @media screen and (orientation: landscape) {
        .sidebar {
          width: 500px; } }
    ```

    `@media` 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：

    ```scss
      $media: screen;
      $feature: -webkit-min-device-pixel-ratio;
      $value: 1.5;

      @media #{$media} and ($feature: $value) {
      .sidebar {
        width: 500px;
      }
      }
    ```

    编译为

    ```css
      @media screen and (-webkit-min-device-pixel-ratio: 1.5) {
        .sidebar {
          width: 500px; } }
    ```

  - **5.3. @extend**

    远离`@extend`，多用`mixins`

  - **5.4. @at-root**

    `@at-root` 指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用：

    ```scss
      .parent {
        ...
        @at-root .child { ... }
      }
    ```

    编译为

    ```css
      .parent { ... }
      .child { ... }
    ```

    也可以与多个内联选择器使用：

    ```scss
      .parent {
        ...
        @at-root {
          .child1 { ... }
          .child2 { ... }
        }
        .step-child { ... }
      }
    ```

    编译为

    ```css
      .parent { ... }
      .child1 { ... }
      .child2 { ... }
      .parent .step-child { ... }
    ```

  - **5.5. @debug**

  - **5.6. @warn**

  - **5.7. @error**
